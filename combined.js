// Copyright (C) 2020 National Center for Atmospheric Research
// SPDX-License-Identifier: Apache-2.0

'use strict'

const app = require('express')();
const http = require('http').Server(app);
const bodyParser = require('body-parser');
app.use(bodyParser.json({limit: '50mb'}));
app.use(bodyParser.urlencoded({limit: '50mb', extended: true}));
app.use(bodyParser.json());

const helmet = require('helmet')
app.use(helmet())
app.use(helmet.contentSecurityPolicy({
  directives:{
    "defaultSrc": ["'self'"],
    "styleSrc": ["'self'"]
  }
}))
app.use(helmet.expectCt({
  enforce: true,
  maxAge: 10
}))
app.use(helmet.frameguard({ action: 'deny' }))
app.disable('x-powered-by')
app.use(helmet.ieNoOpen())
app.use(helmet.noSniff())
app.use(helmet.permittedCrossDomainPolicies())
app.use(helmet.xssFilter())


// get git version hash of this git checkout
//const revision = require('child_process').execSync('git rev-parse HEAD').toString().trim()
//const git_remote = require('child_process').execSync('git config --get remote.origin.url').toString().trim()

const revision = 'NA'
const git_remote = 'NA'

// Set forcing to zero for any net stoichiometric tendency smaller 
//   (in absolute value) than this.
const zero_equivalent_stoichometry_limit = 0.000001

// Some reused code text
const kCodeSeparator = `
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

`;
const kLicenseHeader =
`! Copyright (C) 2020 National Center for Atmospheric Research
! SPDX-License-Identifier: Apache-2.0
!
`;
function getPreprocessedCodeHeader( tag_info ) {
  return `! This code was generated by Preprocessor revision `+revision+`
! Preprocessor source `+git_remote+`
!
! `+tag_info.tagDescription+`
! `+tag_info.tagStats+`
!
`;
}

//   Compute checksum of a string
/*
function generateChecksum(str, algorithm, encoding) {
    return crypto
        .createHash(algorithm || 'md5')
        .update(str, 'utf8')
        .digest(encoding || 'hex');
}
*/


// Collect all molecule names and assign an associative array
// to index them
const moleculeIndexer = function(molecules){
  this.moleculeAssociation = {};
  let i = 0;
  for (i = 0; i < molecules.length; i++){
    this.moleculeAssociation[molecules[i].moleculename]=i;
    molecules[i].idxMoleculeAssocation = i;
  }
  this.numberOfMolecules = i
  this.print = function(){
    //console.log(this.moleculeAssociation);
  }
  this.getMoleculeIndex = function() {return (this.moleculeAssociation);}
}

const k_collector = function() {
  this.mapping = [];
  this.kLabel = [];
  this.photolysisLabel = [];
  this.add = function(reaction, index){
    this.kLabel.push({"simulationIndex":index,"kRateDescription":reaction.reactionString});
    let parameters = reaction.rate_constant.parameters;
    if (reaction.rate_constant.reaction_class == "photolysis") {
      this.photolysisLabel.push(reaction.label);
      parameters['photolysis_rate_constant_index'] = this.photolysisLabel.length;
    }
    this.mapping.push({'index':index, 'reaction_class':reaction.rate_constant.reaction_class,
                       'parameters':reaction.rate_constant.parameters ,'label':reaction.label,
                       'reaction_string':reaction.reactionString});
  }
  this.toCode = function(indexOffset){
    let codeString  =
`  !> Calculate the rate constant for each reaction
  subroutine calculate_rate_constants( rate_constants, environment )

    !> Rate constant for each reaction [(molec cm-3)^(n-1) s-1]
    real(kind=musica_dk), intent(out) :: rate_constants(ncell,number_of_reactions)
    !> Environmental states for each grid cell
    type(environment_t),  intent(in)  :: environment(ncell)

    type( rate_constant_arrhenius_t                   ) :: arrhenius
    type( rate_constant_photolysis_t                  ) :: photolysis
    type( rate_constant_ternary_chemical_activation_t ) :: ternary_chemical_activation
    type( rate_constant_troe_t                        ) :: troe
    type( rate_constant_wennberg_alkoxy_t             ) :: wennberg_alkoxy
    type( rate_constant_wennberg_nitrate_t            ) :: wennberg_nitrate
    type( rate_constant_wennberg_tunneling_t          ) :: wennberg_tunneling

    integer :: i

`;
    for(let i=0; i< this.mapping.length; i++){
      let k_index = indexOffset + this.mapping[i].index;
      let rate_constant_string = "";
      rate_constant_string += "    !"+ this.mapping[i].label + "\n";
      rate_constant_string += "    !"+ this.mapping[i].reaction_string + "\n";
      rate_constant_string += "    "  + this.mapping[i].reaction_class + " = rate_constant_" +
                             this.mapping[i].reaction_class + "_t( &\n";
      let rate_parameters = [ ];
      for (var key in this.mapping[i].parameters) {
        if (this.mapping[i].parameters.hasOwnProperty(key)){
           rate_parameters.push("      " + key + " = " + this.mapping[i].parameters[key]);
        }
      }
      rate_constant_string += rate_parameters.join(", &\n") + " )\n";
      rate_constant_string += "    !$acc enter data copyin("+this.mapping[i].reaction_class+") async(STREAM0)\n";
      rate_constant_string += "    call "+this.mapping[i].reaction_class+"%calculate( environment, rate_constants(1:ncell,"+k_index+") )\n";
      rate_constant_string += "    !$acc exit data delete("+this.mapping[i].reaction_class+") async(STREAM0)\n\n";
      this.kLabel[i].simulationIndex = k_index;
      codeString += rate_constant_string;

    }
    codeString += "  end subroutine calculate_rate_constants\n";
    return codeString;
  }
}

// Data type to be converted to code
// Code will be netTendency*rateConstant(idxReaction)*product_of_vmr_array*M
//   I.E., 0.6*rateConstant(22)*vmr(8)*vmr(3)*M
//      or 0.6*rateConstant(22)*vmr(8)*vmr(3)*numberDensity^3
// arrayOfVmr is array of vmr's by label.  
//
// Rendering takes place later, using the pivot array from the LU factorization routine
function term(idxReaction, arrayOfVmr, troeTerm=false, netTendency=1, reactionString = ""){
  this.idxReaction=idxReaction;
  this.arrayOfVmr=arrayOfVmr;
  this.troeTerm=troeTerm;
  this.netTendency=netTendency;
  this.reactionString=reactionString;
}


// This should be part of the database!
// Decorates the reaction with a "raw label"
// label is constructed as
//   'reactant1'_'reactant2'_M_a_count
//   i.e., O2_O3_M_a_1
//     or  O_O2_M_a_2
//   where count is an index separating reactions having same reactants and same branch
//   "a" or "b" indicates a branch of a reaction
const labelor = function() {
  //
  // global index into list of all types of reactions
  let idxReaction = 0;

  // array of how often a rawLabel appears
  let collection = []; 

  this.add = function(reaction, reactionTypeIndex, reactionType){
    let rawLabel ="";

    if(reaction.reactants.length == 0){
      rawLabel = "None";
    } else {
      rawLabel = reaction.reactants.sort().join("_");
    }

    if (reaction.reactionBranch) { 
      rawLabel += "_" + reaction.reactionBranch;
    }

    if (reaction.troe) {
      rawLabel += "_M"; 
    }

    // figure out if this rawLabel is already present
    let position = collection.map(function(e) { return e.rawLabel; }).indexOf(rawLabel);
    let count = 0;
    if(position > -1) {
      collection[position].count ++;
      count = collection[position].count;
    } else {
      collection.push({rawLabel:rawLabel,count:1});
      count = 1;
    }

    // Add reaction string {j,k} : (troe? M, : "")  reactants -> products
    let reactionString = "";
    reactionString = (reactionType == "reaction") ? "k_"+rawLabel+"_"+count+": ":reactionString;
    reactionString = (reactionType == "photoDecomp") ? "j_"+rawLabel+"_"+count+": ":reactionString;
    reactionString = reactionString + (reaction.troe ? "M, " : "");
    reactionString = reactionString + reaction.reactants.join(" + ");
    reactionString = reactionString + " -> ";
    reactionString = reactionString + reaction.products.map(function(elem){return parseFloat(elem.coefficient)+"*"+elem.molecule}).join(" + ");

    // decorate reaction
    reaction.rawLabel = rawLabel;
    reaction.label = reaction.rawLabel+"_"+count;
    reaction.reactionTypeIndex = reactionTypeIndex;
    reaction.reactionType = reactionType;
    reaction.idxReaction = idxReaction;
    reaction.reactionString = reactionString;
    idxReaction ++;
  }

  this.printCollection = function() {
    //console.log('Number of raw Labels: '+collection.length);
    //console.log('Number of times each rawLabel appears');
    //console.dir(this.collection);
  }

  this.getCollection = function(){
    return collection;
  }

}



// Iterate through the list of reactants and products to create a net stoichiometric tendency
//   of each molecule in the given reaction.
// If net tendency is smaller than a limit, eliminate it from the array of tendencies
// Decorate each reaction with an array of net stoichiometric tendencies for the molecules
const stoichiometricTendencies = function(reaction, molecules) {

  let tendency = []; // tendency array for this reaction
  let tendencyCount = 0;

  reaction.reactants.forEach( function(reactant){
    let indexOfReactant = molecules.map(function(e) { return e.moleculename; }).indexOf(reactant);
    tendency[tendencyCount] = {idxConstituent:indexOfReactant, constituent:reactant, netTendency:-1};
    tendencyCount ++;
  });

  reaction.products.forEach( function(product){
    let position = tendency.map(function(e) { return e.constituent; }).indexOf(product.molecule);
    let indexOfReactant = molecules.map(function(e) { return e.moleculename; }).indexOf(product.molecule);
    if( position < 0 ){ 
      // This product is not in the list of reactants
      tendency.push({idxConstituent:indexOfReactant, constituent:product.molecule, netTendency:product.coefficient});
    } else { 
      // This product is in the list of reactants, so accumulate net tendency
      tendency[position].netTendency += product.coefficient;
      tendencyCount ++;
    }
  });

  // Remove terms with roundoff-level-zero stoichiometric coefficients
  var tendency_nonzero = [];
  for( var i = 0; i < tendency.length; i++){
    if(Math.abs(tendency[i].netTendency) > zero_equivalent_stoichometry_limit ){ 
      tendency_nonzero.push(tendency[i]);
    }
  }

  // Decorate the reaction with the tendencies
  //   reaction.tendencies = [ {idxConstituent:22, constituent:'O2', netTendency:-0.5}, ...]
  reaction.tendencies = tendency_nonzero;

}




// Collect forcing for each molecule.  This is the 
//   right hand side of the differential equation for
//   each molecule.  It may be useful to compute forcing
//   for each reaction and apply it to each molecule, Or
// One can use this collection to compute forcing for each
//   molecule using a number of rates.
// Also construct the jacobian of the forcing, i.e. the
//   sensitivity of the forcing to the concentrations of each constituent
// Also construct logical jacobian for forcing, i.e. whether or not
//   the forcing is sensitive to the concentrations of each constituent
const forceCollector = function(molecules){

  // forcing (i.e., rate of change) of each molecule
  var force = [];
  // jacobian d(force)/dMolecule
  var jacobian = [];
  // matrix of Boolean.  Entries are true if the jacobian has an entry, or if it is filled in by pivoting
  var logicalJacobian = []; 

  // Compute number of molecules in the mechanism
  let count = molecules.length;

  // Initialize storage for forcing, jacobian, and logicalJacobian
  for(let iMolecule = 0; iMolecule < count; iMolecule++){
    force[iMolecule] = {};
    force[iMolecule].constituentName = molecules[iMolecule].moleculename;
    force[iMolecule].idxConstituent = iMolecule;
    // net stoichiometric tendency of every constituent in the reaction
    force[iMolecule].tendency = [];
    // each jacobian element is an array of terms
    jacobian[iMolecule] = [];
    for(let jMolecule = 0; jMolecule < count; jMolecule++){
      jacobian[iMolecule][jMolecule] = [];
    }
    // each logicalJacobian element is true/false
    logicalJacobian[iMolecule] = [];
    for(let jMolecule = 0; jMolecule < count; jMolecule++){
      logicalJacobian[iMolecule][jMolecule] = false;
    }
  }
  

  // construct forcing, logicalJacobian, and jacobian from each reaction
  this.constructForcingFromTendencies = function(reaction, moleculeIndex){

    //let rate=new term(reaction.idxReaction, reaction.reactants, reaction.troe, 1, reaction.reactionString);

    let nTends = reaction.tendencies.length;

    for (let iTend = 0; iTend < nTends; iTend++){
      let tendency = reaction.tendencies[iTend];
      let forcedMoleculeIndex = tendency.idxConstituent;
      if (forcedMoleculeIndex == -1 ) break;  // molecule not in the list of molecules-> don't consider it.
      
      force[forcedMoleculeIndex].tendency.push(new term(reaction.idxReaction, reaction.reactants, reaction.troe, tendency.netTendency, reaction.reactionString));
      //force[forcedMoleculeIndex].tendency.push({tendency:tendency.netTendency, rate:rate});
        
      // jacobian: derivative of forcing[tendency.constituent] w/r/t each tendency in the reaction list
      for(let i = 0; i < reaction.reactants.length; i++){

        //console.log("derivative of "+ tendency.constituent+ " w/r/t/ "+reaction.reactants[i]);
        let sensitivityIndex = moleculeIndex.moleculeAssociation[reaction.reactants[i]];
        logicalJacobian[forcedMoleculeIndex][sensitivityIndex] = true;

        // Jacobian terms.  Rate is tendency * rate_constant * [product of reactant_array] * M (if troe)
        // Jacobian is (net stoichiometry term for molecule) * rate.
        // For the derivitive w.r.t. each reactant, construct 
        //   tendency * rate_constant * [product of reactant_array without the sensitivity molecule] * M (if troe)

        // Construct reactant array without each sensitivity molecule
        let remainingTerms = reaction.reactants.slice(0); // replicate
        remainingTerms.splice(i,1); // remove this term

        // jacTerm = {rateConstantIndex:idxReaction, arrayOfVmr:['O2'], troeTerm:reaction.troe, netTendency:-0.25]}
        let jacTerm = new term(reaction.idxReaction, remainingTerms, reaction.troe, tendency.netTendency, reaction.reactionString);
        jacobian[forcedMoleculeIndex][sensitivityIndex].push(jacTerm);
      }

    }

  }


  this.printForce = function(){
    force.forEach( function(f){
       //console.log(f.constituent);
       //console.log(f.tendency);
    });
  }

  this.printForcing = function(){
    for(let i = 0; i < molecules.length; i++){
      if(force[i].tendency.length > 0) {
        //console.log('forcing of molecule '+molecules[i].moleculename)
        for( let j = 0; j < force[i].tendency.length; j++){
          //console.log(force[i].tendency[j])
        }
      }
    }
  }

  this.printLogicalJacobian = function(){
    //console.log(' ---- Logical Jacobian ---- ');
    for(let i = 0; i < force.length; i++){
      //console.log(molecules[i].moleculename);
      //console.log(logicalJacobian[i]);
    }
  }

  this.printJacobian = function(){
    //console.log(' ---- Jacobian ---- ');
    for(let i = 0; i < molecules.length; i++){
      for(let j = 0; j < molecules.length; j++){
        let jacstring = "";
        //console.log(molecules[i].moleculename + ',' +molecules[j].moleculename) 
        //console.dir(jacobian[i][j])
      }
    }
  }



  this.getLogicalJacobian = function(){
    return logicalJacobian ;
  }

  this.getJacobian = function(){
    return jacobian ;
  }

  this.getForce = function(){
    return force ;
  }

}

const kRateConstantParameters = {
  arrhenius:                   { A: 'double', B:'double', C: 'double', D: 'double', E: 'double', Ea: 'double' },
  photolysis:                  { },
  ternary_chemical_activation: { k0_A: 'double', k0_B: 'double', k0_C: 'double', kinf_A: 'double',
                                 kinf_B: 'double', kinf_C: 'double', Fc: 'double', N: 'double' },
  troe:                        { k0_A: 'double', k0_B: 'double', k0_C: 'double', kinf_A: 'double',
                                 kinf_B: 'double', kinf_C: 'double', Fc: 'double', N: 'double' },
  wennberg_alkoxy:             { X: 'double', Y: 'double', a0: 'double', n: 'int' },
  wennberg_nitrate:            { X: 'double', Y: 'double', a0: 'double', n: 'int' },
  wennberg_tunneling:          { A: 'double', B: 'double', C: 'double' }
};

const kTypeCasting = { double: { prefix: 'real( ', suffix: ', kind=musica_dk )' },
                       int: { prefix: '', suffix: '' } };

// Rate constant parameter set
const RateConstant = function(data) {
  this.reaction_class = data['type'].toLowerCase();
  this.parameters = {};
  var self = this;
  for (const [parameter, type] of Object.entries(kRateConstantParameters[this.reaction_class])) {
    if (parameter in data) self.parameters[parameter] = kTypeCasting[type].prefix + data[parameter] + kTypeCasting[type].suffix;
  }
}

// Chemical reaction or process
const Reaction = function(reaction_data) {
  this.data = reaction_data;
  this.reactants = [];
  this.products  = [];
  this.troe = false;
  this.rate_constant = new RateConstant(reaction_data);
  for (const [reactant, props] of Object.entries(this.data.reactants)) {
    var qty = 1;
    if ('qty' in props) qty = props['qty'];
    for (var i = 0; i < qty; ++i) this.reactants.push(reactant);
  }
  for (const [product, props] of Object.entries(this.data.products)) {
    var prod_obj = { molecule: product, coefficient: 1 };
    if ('yield' in props) prod_obj['coefficient'] = props['yield'];
    this.products.push(prod_obj);
  }
}

// Chemical species
const Species = function(species_data) {
  this.data = species_data;
  this.moleculename = species_data['name'];
  this.solve = 'implicit';
}

// Chemical mechanism from json configuration
const Mechanism = function(config_data) {
  this.name;
  this.species = [];
  this.reactions = [];
  for (const [file_name, file_data] of Object.entries(config_data)) {
    for (const [element, element_data] of Object.entries(file_data['camp-data'])) {
      if (!('type' in element_data)) continue;
      if (element_data['type'] == 'MECHANISM') {
        if (this.name == undefined) this.name = element_data['name'];
        if (this.name != element_data['name']) {
          throw "Error: multiple mechanisms present in input data: ${this.name}, ${element_data['name']}";
        }
        var self = this;
        element_data['reactions'].forEach(function(reaction) {
          // split WENNBERG_NO_RO2 into WENNBERG_NITRATE and WENNBERG_ALKOXY
          if (reaction['type'] == 'WENNBERG_NO_RO2') {
            let wennberg_data = reaction;
            if (wennberg_data['alkoxy products'].length > 0) {
              wennberg_data['products'] = wennberg_data['alkoxy products'];
              wennberg_data['type'] = 'WENNBERG_ALKOXY';
              self.reactions.push(new Reaction(reaction));
            }
            if (wennberg_data['nitrate products'].length > 0) {
              wennberg_data['products'] = wennberg_data['nitrate products'];
              wennberg_data['type'] = 'WENNBERG_NITRATE';
              self.reactions.push(new Reaction(wennberg_data));
            }
          } else {
            self.reactions.push(new Reaction(reaction));
          }
        });
      } else if (element_data['type'] == 'CHEM_SPEC') {
        this.species.push(new Species(element_data));
      }
    }
  }
  this.tag_info = function() {
    var obj = {
      id: "unknown",
      given_name: this.name,
      initials: "unknown",
      branchname: "unknown",
      branch_id: "unknown",
      date: "unknown",
      buggy: false,
      filename: this.name
    }
    return obj;
  }
}

function constructJacobian(req, res, next) {

  // Only use the body of the request.
  // Ignore header data.
  var content = req.body;

  // Extract relevant data from the request.
  let mechanism = new Mechanism(content);
  let molecules = mechanism.species;
  let reactions = mechanism.reactions;
  let photoDecomps = [];
  let tag_info  = mechanism.tag_info;
  tag_info.tagDescription = "This code is generated from tag "+tag_info.id+" of the mechanism, "+tag_info.branchname+ ".  It is named "+tag_info.given_name;
  tag_info.tagStats = "This tag was created on "+tag_info.date+" by "+tag_info.initials+" and is marked as "+(tag_info.buggy?"buggy ":"not buggy");

  // Labelling should be done in the database.
  // For now, do the labelling here.
  var label = new labelor();

  // Construct an index into the molecule array
  // I.E., moleculeIndex.moleculeAssociation[molecules[i].moleculename]=i;
  var moleculeIndex = new moleculeIndexer(molecules);

  // Initialize the forceCollection to store relevant
  //   forcing, jacobian, and logicalJacobian
  var forceCollection = new forceCollector(molecules);

  var k_collection = new k_collector();

  // Label each reaction
  // Decorate each reaction with 
  //   a label, 
  //   a global index into list of all reactions, 
  //   the reactionType, 
  //   and an index into that reaction typelist
  reactions.forEach(function(reaction, index){
    label.add(reaction, index, "reaction");
    k_collection.add(reaction, index);
    }
  );

  // Compute tendency of molecules due to each reaction
  reactions.forEach(function(reaction){
    stoichiometricTendencies(reaction, molecules)});

  // Construct force, jacobian and logicalJacobian for each reaction
  reactions.forEach(function(reaction){
    forceCollection.constructForcingFromTendencies(reaction, moleculeIndex)});

  // Get these from the forceCollection
  let logicalJacobian = forceCollection.getLogicalJacobian();
  let jacobian = forceCollection.getJacobian();
  let force = forceCollection.getForce();
  let labelCollection = label.getCollection();

  let mIndex = moleculeIndex.getMoleculeIndex();
  //
  // Send result back to host
  //

  let rate_constant_module = kLicenseHeader + getPreprocessedCodeHeader( tag_info ) +
`!> \\file
!> The mechanism-specific rate constant module

!> Mechanism-specific rate constant functions
module rate_constants_utility

  use micm_environment,                only : environment_t
  use micm_rate_constant_arrhenius,    only : rate_constant_arrhenius_t
  use micm_rate_constant_photolysis,   only : rate_constant_photolysis_t
  use micm_rate_constant_ternary_chemical_activation,                    &
      only : rate_constant_ternary_chemical_activation_t
  use micm_rate_constant_troe,                                           &
      only : rate_constant_troe_t
  use micm_rate_constant_wennberg_alkoxy,                                &
      only : rate_constant_wennberg_alkoxy_t
  use micm_rate_constant_wennberg_nitrate,                               &
      only : rate_constant_wennberg_nitrate_t
  use micm_rate_constant_wennberg_tunneling,                             &
      only : rate_constant_wennberg_tunneling_t
  use musica_constants,                only : musica_dk
  use constants,                       only : ncell=>kNumberOfGridCells, &
                                              VLEN, STREAM0
  use kinetics_utilities,              only : number_of_reactions 

  implicit none
  private

  public :: calculate_rate_constants

contains
` + kCodeSeparator + k_collection.toCode(1) + kCodeSeparator +
`end module rate_constants_utility
`;

  res.locals.preprocessorVersion = revision;
  res.locals.tagDescription = tag_info.tagDescription;
  res.locals.tagStats = tag_info.tagStats;
  res.locals.molecules = molecules; 
  res.locals.reactions = reactions; 
  res.locals.photoDecomps = photoDecomps; 
  res.locals.labelCollection = labelCollection;
  res.locals.logicalJacobian = logicalJacobian; 
  res.locals.jacobian = jacobian;
  res.locals.moleculeIndex = mIndex;
  res.locals.j_labels = k_collection.photolysisLabel;
  res.locals.k_labels = k_collection.kLabel;
  res.locals.rate_constants_utility_module = rate_constant_module;
  res.locals.force = force;

  next()
 
/*
  res.json({
    "preprocessorVersion": revision, 
    "tagDescription":tag_info.tagDescription,
    "tagStats":tag_info.tagStats,
    "molecules": molecules, 
    "reactions":reactions, 
    "photoDecomps":photoDecomps, 
    "labelCollection":labelCollection,
    "logicalJacobian":logicalJacobian, 
    "jacobian":jacobian, 
    "moleculeIndex":mIndex,
    "rate_constant_module":rate_constant_module,
    "force":force
    });
*/
}



function getMinLoc(arr, subMatrixIndex) {
  // find min and max of arr starting at "subMatrixIndex"
  let minLoc = subMatrixIndex;
  let min = arr[minLoc];

  let j = arr.length;

  for (let i = subMatrixIndex; i < j; i++ ) {
    minLoc = arr[i] < min ? i : minLoc;
  }
  return minLoc;
}


function logicalFactorize() {

  this.init = function(sourceMatrix) {
  
    
    this.size = sourceMatrix.length;
    // Create an array filled with false and with true down the diagonal
    // Initial pivot array is simple increasing index
    this.pivot = Array.from(Array(this.size), (x, index) => index);

    this.matrix = new Array(this.size);
    for (var i = 0; i < this.size; i++) {
      this.matrix[i]= sourceMatrix[i].slice(); // replicate row to each row of matrix
    }

    // Put elements down the diagonal
    for (var i = 0; i < this.size; i++) {
       this.matrix[i][i] =  true;
    }
  }
 
  this.switchColAndRow = function(subMatrixIndex, pivotPoint){
    if(subMatrixIndex == pivotPoint) return;
    // Pivot matrix Rows and Columns, exchanging subMatrixIndex and pivotPoint

    // Store pivot choice in pivot array
    var temp = this.pivot[pivotPoint];
    this.pivot[pivotPoint] = this.pivot[subMatrixIndex];
    this.pivot[subMatrixIndex] = temp;

    // Switch the whole column, include the part above
    let leftColumn = this.matrix[subMatrixIndex].slice(); // extract the current left Column
    this.matrix[subMatrixIndex]=this.matrix[pivotPoint].slice();
    this.matrix[pivotPoint]=leftColumn;
 
    // Switch both rows, including part to the left
    for (let diagonalIndex = 0; diagonalIndex < this.size ; diagonalIndex ++) {
      let upperElement = this.matrix[diagonalIndex][pivotPoint]; // future upper element
      this.matrix[diagonalIndex][pivotPoint] = this.matrix[diagonalIndex][subMatrixIndex];
      this.matrix[diagonalIndex][subMatrixIndex] = upperElement;
    }
  }

  this.interactionIndexArray = function(subMatrixIndex) {
    // Compute interaction indicies of submatrix starting at index = subMatrixIndex

    // Number of entries in the row
    let rowCount = new Array(this.size).fill(0);
    // Number of entries in the column
    let colCount = new Array(this.size).fill(0);

    for (let i = subMatrixIndex; i < this.size; i++){
      for (let j = subMatrixIndex; j < this.size; j++){
        if(this.matrix[i][j] && (i != j) ) {  // remove counts for diagonal elements
          rowCount[i] ++;
          colCount[j] ++;
        }
      }
    }

    // compute the "interaction" which is the element-by-element product of these arrays
    let interaction = rowCount.map( (e,i)=> e * colCount[i] );
    //console.log("interaction "+interaction);
    let pivotLoc =  getMinLoc(interaction, subMatrixIndex);
    //console.log("pivot location: " + pivotLoc);
    return(pivotLoc);
  }

  this.printMatrix = function(matrix) {
    for (let i = 0; i < matrix.length ; i++){
      let string = "";
      for (let j = 0; j < matrix.length ; j++){
        string += String("                    "+JSON.stringify(matrix[i][j])).slice(-15);
      }
      //console.log(string);
    }
  }
  
  this.LUFillIn = function(eliminatingRowIndex) {
  // Place a "true" entry in every element which will be filled in as a result of elimination from row.
  // subMatrix is the matrix below and to the right of the eliminatingRow
    for (let row = eliminatingRowIndex+1; row < this.size; row++){
      for (let col = eliminatingRowIndex+1; col < this.size; col++){
        if( !(this.matrix[row][col]) ) {
           if( (this.matrix[row][eliminatingRowIndex]) && (this.matrix[eliminatingRowIndex][col]) ) {
             this.matrix[row][col] = true;
           }
        }
      }
    }
  }

  this.linearArrayMapping = function() {
  // Compute mapping between a linear array containing LU factorization elements and [row][col] dense representation of matrix
    var k = 0;
    this.map = [];
    this.diag = [];
    for (let col = 0; col < this.size; col++){
      this.map[col]=[];
    }
    for (let col = 0; col < this.size; col++){
      for (let row = 0; row < this.size; row++){
        if(this.matrix[row][col]) {
          this.map[row][col] = k;
          if( row == col ) this.diag[col]=k;
          k++
        }
      }
    }
    this.numberSparseFactorElements=k;
  }

  this.getPivot = function(){ 
    return this.pivot;
  }

  this.getDiagIndices = function(){ 
    return this.diag;
  }

}

function diagInv (targetIndex) {
  // LU(targetIndex) = 1/LU(targetIndex)
  this.targetIndex = targetIndex;
}

function leftEliminate (targetIndex, diagonalIndex) {
  // LU(targetIndex) = LU(targetIndex) * LU(diagonalIndex)
  this.targetIndex = targetIndex;
  this.diagonalIndex = diagonalIndex
}

function update (targetIndex, productTerm1, productTerm2) {
  // LU(targetIndex) = LU(targetIndex) - LU(productTerm1)*LU(productTerm2)
  this.targetIndex = targetIndex;
  this.productTerms = [productTerm1, productTerm2];
}

function fill (targetIndex, productTerm1, productTerm2){
  // LU(targetIndex) = -LU(productTerm1)*LU(productTerm2)
  this.targetIndex = targetIndex;
  this.productTerms = [productTerm1, productTerm2];
}

// Given molecules and logical matrix, construct sparse LU factorization
// with corresponding pivoting of molecules and LU backsolves
function constructSparseLUFactor(req, res, next) {

  // collect data from request
  var content = req.body;
  var logicalJacobian = res.locals.logicalJacobian;
  let jacobian = res.locals.jacobian;
  let molecules = res.locals.molecules;
  let force = res.locals.force;

  var logicalFactorization = new logicalFactorize();
  
  // Compute factorization fill-in
  logicalFactorization.init(logicalJacobian) ;
  for (let i = 0; i < logicalFactorization.size ; i++){
    //console.log('row: '+i);
    let minLoc = logicalFactorization.interactionIndexArray(i);
    //console.log('Pivot: '+ i + " and " + minLoc);
    logicalFactorization.switchColAndRow(i, minLoc);
    logicalFactorization.LUFillIn(i)
  }
  
  // Compute mapping from [i,j] to linear array of LU(:)
  logicalFactorization.linearArrayMapping();

  const accumulatedFortanLUFactorization = [];
  const LUFactorization = [];

  // generate Fortran
  for (let rankIndex = 0; rankIndex < logicalFactorization.size; rankIndex++){
    LUFactorization.push(new diagInv(logicalFactorization.diag[rankIndex]));
    accumulatedFortanLUFactorization.push('LU('+logicalFactorization.diag[rankIndex]+') = 1./LU('+logicalFactorization.diag[rankIndex]+')');
    if( rankIndex < logicalFactorization.size-1 ){
      for (let row = rankIndex + 1; row < logicalFactorization.size; row++){
        if( logicalFactorization.matrix[row][rankIndex]){
          LUFactorization.push(new leftEliminate(logicalFactorization.map[row][rankIndex],logicalFactorization.diag[rankIndex]));
          let fortranString = 'LU('+logicalFactorization.map[row][rankIndex] + ')';
          fortranString += ' = LU('+logicalFactorization.map[row][rankIndex]+')*LU('+logicalFactorization.diag[rankIndex]+')';
          accumulatedFortanLUFactorization.push(fortranString);
        }
      }
      for (var col = rankIndex + 1; col < logicalFactorization.size; col++){
        if(logicalFactorization.matrix[rankIndex][col]){
          for ( var row = rankIndex + 1; row < logicalFactorization.size; row++){
            if(logicalFactorization.matrix[row][rankIndex]){
// THIS IS A WRONG:
              if(logicalFactorization.matrix[row][col] ){
                LUFactorization.push( new update(logicalFactorization.map[row][col],logicalFactorization.map[row][rankIndex], logicalFactorization.map[rankIndex][col]));
                let indx=logicalFactorization.map[row][col];
                let indx1=logicalFactorization.map[row][rankIndex];
                let indx2=logicalFactorization.map[rankIndex][col];
                let fortranString = 'LU('+indx+') = LU('+indx+') - LU('+indx1+')*LU('+indx2+')';
                accumulatedFortanLUFactorization.push(fortranString);
              }else{
                let indx=logicalFactorization.map[row][col];
                let indx1=logicalFactorization.map[row][rankIndex];
                let indx2=logicalFactorization.map[rankIndex][col];
                LUFactorization.push(new fill(logicalFactorization.map[row][col],logicalFactorization.map[row][rankIndex], logicalFactorization.map[rankIndex][col]));
                logicalFactorization.matrix[row][col]=true;
                let fortranString = 'LU('+indx+') = -LU('+indx1+')*LU('+indx2+')';
                accumulatedFortanLUFactorization.push(fortranString);
              }
            }
          }
        }
      }
    }
  }
  

  var init_jac = [];
  for (var col = 0; col < logicalFactorization.matrix.length; col++){
    for (var row = 0; row < logicalFactorization.matrix.length; row++){
      if(jacobian[row][col].length > 0 ){ 
        let iRow = logicalFactorization.pivot.indexOf(row);
        let iCol = logicalFactorization.pivot.indexOf(col);
        init_jac.push({
          "forcedMolecule":molecules[row].moleculename ,
          "sensitivityMolecule": molecules[col].moleculename,
          "LUArrayIndex":logicalFactorization.map[iRow][iCol],
          "jacobianTerms":jacobian[row][col],
          "LUFactorization":LUFactorization,
          "diagonalIndices":logicalFactorization.getDiagIndices()
        });
      }
    }
  }

  var factor_LU_fortran = "\n";
  factor_LU_fortran += 'subroutine factor(LU)\n';
  factor_LU_fortran += '\n';
  factor_LU_fortran += '  real(r8), intent(inout) :: LU(ncell,number_sparse_factor_elements)\n';
  factor_LU_fortran += '\n';
  factor_LU_fortran += '  integer :: i\n';
  factor_LU_fortran += '\n';
  factor_LU_fortran += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n';
  factor_LU_fortran += '  !$acc loop gang vector\n';
  factor_LU_fortran += '  do i = 1, ncell\n';

  var alt_factor = function(LUFactorization){

    diagInv.prototype.toCode = function(iOffset=0) {
      let targetI = iOffset + parseInt(this.targetIndex);
      let fortranString = '     LU(i,'+ targetI +') = 1./LU(i,'+ targetI +')\n';
      return fortranString;
    }

    leftEliminate.prototype.toCode = function(iOffset=0) {
      let targetI = iOffset + parseInt(this.targetIndex);
      let diagI = iOffset + parseInt(this.diagonalIndex);
      let fortranString = '     LU(i,' + targetI + ') = LU(i,' + targetI + ') * LU(i,' + diagI + ')\n';
      return fortranString;
    }

    update.prototype.toCode = function(iOffset=0) {
      let targetI = iOffset + parseInt(this.targetIndex);
      let prodI0 = iOffset + parseInt(this.productTerms[0]);
      let prodI1 = iOffset + parseInt(this.productTerms[1]);
      let fortranString = '     LU(i,'+ targetI +') = LU(i,'+ targetI +') - LU(i,'+ prodI0 +')*LU(i,'+ prodI1 +')\n';
      return fortranString;
    }

    fill.prototype.toCode = function(iOffset=0){ 
      let targetI = iOffset + parseInt(this.targetIndex);
      let prodI0 = iOffset + parseInt(this.productTerms[0]);
      let prodI1 = iOffset + parseInt(this.productTerms[1]);
      let fortranString = '     LU(i,'+ targetI +') = -LU(i,'+ prodI0 +')*LU(i,'+ prodI1 +')\n';
      return fortranString;
    }


    var fortranOffset = 1;

    let fortranCodeArray = LUFactorization.map( 
      (step) => {
        return step.toCode(fortranOffset);
      } 
    );

    factor_LU_fortran += fortranCodeArray.join("");

    factor_LU_fortran += '  end do\n';
    factor_LU_fortran += '  !$acc end parallel\n';
    factor_LU_fortran += '\n';
    factor_LU_fortran += 'end subroutine factor\n\n\n';
    return factor_LU_fortran;
  }


  var backsolve_L_y_eq_b_fortran = "\n";
  backsolve_L_y_eq_b_fortran += 'subroutine backsolve_L_y_eq_b(LU,b,y)\n';
  backsolve_L_y_eq_b_fortran += '\n'
  backsolve_L_y_eq_b_fortran += '  real(r8), intent(in) :: LU(ncell,number_sparse_factor_elements)\n';
  backsolve_L_y_eq_b_fortran += '  real(r8), intent(in) :: b(ncell,number_of_species)\n';
  backsolve_L_y_eq_b_fortran += '  real(r8), intent(out) :: y(ncell,number_of_species)\n';
  backsolve_L_y_eq_b_fortran += '\n'
  backsolve_L_y_eq_b_fortran += '  integer :: i\n'
  backsolve_L_y_eq_b_fortran += '\n'
  backsolve_L_y_eq_b_fortran += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n'
  backsolve_L_y_eq_b_fortran += '  !$acc loop gang vector\n'
  backsolve_L_y_eq_b_fortran += '  do i = 1, ncell\n'
  for(var row = 0; row < logicalFactorization.size; row++){
    let fortran_row = row + 1;
    backsolve_L_y_eq_b_fortran += '    y(i,'+fortran_row+') = b(i,'+fortran_row+')\n';
    for(var col = 0; col < row; col++){
      let fortran_col = col + 1;
      let LUIndex = logicalFactorization.map[row][col] + 1;
      if(logicalFactorization.map[row][col]){
        backsolve_L_y_eq_b_fortran +='    y(i,'+fortran_row+') = y(i,'+fortran_row+') - LU(i,'+LUIndex+') * y(i,'+fortran_col+')\n'
      }
    }
  }
  backsolve_L_y_eq_b_fortran += '  end do\n'
  backsolve_L_y_eq_b_fortran += '  !$acc end parallel\n'
  backsolve_L_y_eq_b_fortran += '\n'
  backsolve_L_y_eq_b_fortran += 'end subroutine backsolve_L_y_eq_b\n\n\n';
  //console.log(backsolve_L_y_eq_b_fortran);


  var backsolve_U_x_eq_y_fortran = '\nsubroutine backsolve_U_x_eq_y(LU,y,x)\n';
  backsolve_U_x_eq_y_fortran +='\n'
  backsolve_U_x_eq_y_fortran +='  real(r8), intent(in) :: LU(ncell,number_sparse_factor_elements)\n'
  backsolve_U_x_eq_y_fortran +='  real(r8), intent(in) :: y(ncell,number_of_species)\n'
  backsolve_U_x_eq_y_fortran +='  real(r8), intent(out) :: x(ncell,number_of_species)\n'
  backsolve_U_x_eq_y_fortran +='\n'
  backsolve_U_x_eq_y_fortran +='  ! Local variables\n'
  backsolve_U_x_eq_y_fortran +='  real(r8) :: temporary\n'
  backsolve_U_x_eq_y_fortran +='  integer :: i\n'
  backsolve_U_x_eq_y_fortran +='\n'
  backsolve_U_x_eq_y_fortran +='  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n'
  backsolve_U_x_eq_y_fortran +='  !$acc loop gang vector\n'
  backsolve_U_x_eq_y_fortran +='  do i = 1, ncell\n'
  for(var row = logicalFactorization.size-1; row > -1; row--){
    let fortran_row = row + 1;
    backsolve_U_x_eq_y_fortran +='    temporary = y(i,'+fortran_row+')\n'
    for(var col = row+1; col < logicalFactorization.size; col++){
      let fortran_col = col + 1;
      let LUIndex = logicalFactorization.map[row][col] + 1;
      if(logicalFactorization.map[row][col]){
        backsolve_U_x_eq_y_fortran +='    temporary = temporary - LU(i,'+LUIndex+') * x(i,'+fortran_col+')\n'
      }
    }
    let LUIndex = logicalFactorization.map[row][row] + 1;
    backsolve_U_x_eq_y_fortran +='    x(i,'+fortran_row+') = LU(i,'+LUIndex+') * temporary\n';
  }
  backsolve_U_x_eq_y_fortran +='  end do\n'
  backsolve_U_x_eq_y_fortran +='  !$acc end parallel\n'
  backsolve_U_x_eq_y_fortran +='\n'
  backsolve_U_x_eq_y_fortran +='end subroutine backsolve_U_x_eq_y\n\n\n';
  //console.log(backsolve_u_x_eq_y_fortran);

  let solve_string = "\n";
  solve_string += "subroutine solve(LU,x,b)\n";
  solve_string += "\n";
  solve_string += "  real(r8), intent(in) :: LU(ncell,number_sparse_factor_elements), &\n";
  solve_string += "                          b(ncell,number_of_species) ! solve LU * x = b\n";
  solve_string += "  real(r8), intent(out) :: x(ncell,number_of_species)\n\n";
  solve_string += "  ! Local variables\n";
  solve_string += "  real(r8) :: y(ncell,number_of_species)\n";
  solve_string += "\n";
  solve_string += "  !$acc enter data create(y) async(STREAM0)\n";
  solve_string += "\n";
  solve_string += "  call backsolve_L_y_eq_b(LU, b, y)\n";
  solve_string += "  call backsolve_U_x_eq_y(LU, y, x)\n";
  solve_string += "\n";
  solve_string += "  !$acc exit data delete(y) async(STREAM0)\n";
  solve_string += "\n";
  solve_string += "end subroutine solve\n\n";

  var reorderedMolecules = [];
  for(let i = 0; i< molecules.length; i++){
    reorderedMolecules[i]=molecules[logicalFactorization.pivot[i]];
    reorderedMolecules[i].postPivotIndex=logicalFactorization.pivot[i];
  }
  //console.log(reorderedMolecules);

  var reorderedForcing = [];
  for(let i = 0; i< molecules.length; i++){
    reorderedForcing[i]=force[logicalFactorization.pivot[i]];
  }

  var pivot = logicalFactorization.pivot;
 
  let alt_fortranFactor = alt_factor(LUFactorization);

  let indexOffset = 1; //convert to fortran
  let module = "module factor_solve_utilities\n\n";
  module += "use musica_constants,   only : r8 =>musica_dk\n"
  module += "use constants,          only : ncell=>kNumberOfGridCells, VLEN, &\n";
  module += "                               STREAM0\n\n";
  module += "! This code was generated by Preprocessor revision "+revision+"\n";
  module += "! Preprocessor source "+git_remote+"\n\n";
  module += "! "+res.locals.tagDescription+"\n";
  module += "! "+res.locals.tagStats+"\n\n";
  module += "  implicit none\n\n";
  module += "  public :: factor, solve\n";
  module += "\n";
  module += "  integer, parameter, public  :: number_of_species                  = "+reorderedMolecules.length+"\n"
  module += "  integer, parameter, public  :: number_sparse_factor_elements      = "+logicalFactorization.numberSparseFactorElements+"\n\n";
  module += "  contains\n\n";
  module += backsolve_L_y_eq_b_fortran;
  module += backsolve_U_x_eq_y_fortran;
  module += factor_LU_fortran;
  module += solve_string;
  module += "\nend module factor_solve_utilities\n";

  res.locals.preprocessorVersion = revision; 
  res.locals.tagDescription = res.locals.tagDescription;
  res.locals.tagStats = res.locals.tagStats;
  res.locals.reorderedMolecules = reorderedMolecules;
  res.locals.backsolve_L_y_eq_b_fortran = backsolve_L_y_eq_b_fortran;
  res.locals.backsolve_U_x_eq_y_fortran = backsolve_U_x_eq_y_fortran;
  res.locals.solve = solve_string;
  res.locals.factor_LU_fortran = factor_LU_fortran;
  res.locals.pivot = pivot;
  res.locals.reorderedForcing = reorderedForcing;
  res.locals.init_jac = init_jac;
  res.locals.factor_solve_utilities_module = module


  next()

/*
  res.json({
    "preprocessorVersion": revision, 
    "tagDescription":content.tagDescription,
    "tagStats":content.tagStats,
    "reorderedMolecules":reorderedMolecules,
    "backsolve_L_y_eq_b_fortran":backsolve_L_y_eq_b_fortran,
    "backsolve_U_x_eq_y_fortran":backsolve_U_x_eq_y_fortran,
    "solve":solve_string,
    "factor_LU_fortran":factor_LU_fortran,
    "pivot":pivot,
    "reorderedForcing":reorderedForcing,
    "init_jac":init_jac,
    "module":module
    });
*/

}





function reorderedIndex (reorderedMolecules){
  // caution:  modifies reorderedMolecules
  let index = {};
  for (let i = 0; i < reorderedMolecules.length; i++){
    index[reorderedMolecules[i].moleculename]=i;
    reorderedMolecules[i].idxMoleculeAssocation = i;
  }
  return index;
}


// convert terms to rate calculating code
// expressions are of the following form:
//   netTendency * product of reactants * conversion to number_density * rateConstant
function termToRateCode(term, moleculeIndex, indexOffset) {
  let idxReaction = term.idxReaction;
  let arrayOfVmr = term.arrayOfVmr;
  let troeTerm = term.troeTerm;
  let reactionString = term.reactionString;

  let rateConstString = "rate_constant(i," +(parseInt(idxReaction) + parseInt(indexOffset))+")";
  let troeDensityCount = (troeTerm ? 1 : 0);
  let troeDensityConversion = (troeTerm ? "number_density_air(i)" : "");


  let numberDensityArray =[];
  for(let iVmr = 0; iVmr < arrayOfVmr.length; iVmr++){
    numberDensityArray.push("number_density(i,"+ (parseInt(indexOffset) + parseInt(moleculeIndex[arrayOfVmr[iVmr]])) +")");
  }
  if(troeTerm) {numberDensityArray.push(troeDensityConversion);}

  let arrayOfNumberDensityString = "";
  let termString = "";
  if (arrayOfVmr.length > 0) {
    arrayOfNumberDensityString = numberDensityArray.join(" * ") 
    termString = rateConstString + " * " + arrayOfNumberDensityString;
  } else {
    termString = rateConstString;
  }

  return termString;
}

// convert terms to code
// expressions are of the following form:
//   netTendency * product of reactants * conversion to number_density * rateConstant
function termToCode (term, moleculeIndex, indexOffset) {
  let rateString = termToRateCode(term, moleculeIndex, indexOffset);
  let netTendency = term.netTendency;

  let termString = "";
  if (netTendency > 0) {
    if (netTendency != 1){
      termString = "+ "+netTendency+"*" +rateString;
    } else {
      termString = "+ "+rateString;
    }
  } else {
    if (netTendency != -1){
      termString = "- "+Math.abs(netTendency)+"*" +rateString;
    } else {
      termString = "- "+rateString;
    }
  }
  return termString;

}

function toCode(req, res, next) {

  // collect data from request
  let content = req.body;
  let reorderedMolecules = res.locals.reorderedMolecules;
  let init_jac = res.locals.init_jac;
  let force = res.locals.reorderedForcing;
  let reactions = res.locals.reactions;
  let photolysisLabels = res.locals.j_labels;

  let allReactions = [];
  reactions.forEach(function(reaction) {
    allReactions.push(reaction);
  });

  // find index for molecules, as reordered by pivot
  var moleculeIndex =reorderedIndex(reorderedMolecules);

  // code to initialize jacobian
  init_jac.toCode = function(indexOffset=0){
    let init_jac_code_string = "\n";
    init_jac_code_string += '\nsubroutine dforce_dy(LU, rate_constant, number_density, number_density_air)\n';
    init_jac_code_string += "  ! Compute the derivative of the Forcing w.r.t. each chemical\n";
    init_jac_code_string += "  ! Also known as the Jacobian\n";
    init_jac_code_string += '  real(r8), intent(out) :: LU(ncell,number_sparse_factor_elements)\n';
    init_jac_code_string += '  real(r8), intent(in) :: rate_constant(ncell,number_of_reactions)\n';
    init_jac_code_string += '  real(r8), intent(in) :: number_density(ncell,number_of_species)\n';
    init_jac_code_string += '  real(r8), intent(in) :: number_density_air(ncell)\n';
    init_jac_code_string += '\n';
    init_jac_code_string += '  ! Local variables\n';
    init_jac_code_string += '  integer :: i, j \n';
    init_jac_code_string += '\n';
    init_jac_code_string += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n';
    init_jac_code_string += '  !$acc loop gang vector collapse(2)\n';
    init_jac_code_string += '  do j = 1, number_sparse_factor_elements\n';
    init_jac_code_string += '     do i = 1, ncell\n';
    init_jac_code_string += '        LU(i,j) = 0\n';
    init_jac_code_string += '     end do\n';
    init_jac_code_string += '  end do\n';
    init_jac_code_string += '  !$acc end parallel\n';
    init_jac_code_string += '\n';
    init_jac_code_string += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n';
    init_jac_code_string += '  !$acc loop gang vector\n';
    init_jac_code_string += '  do i = 1, ncell\n';
    for (let ijac = 0; ijac < init_jac.length; ijac++){
      let element = init_jac[ijac];
      init_jac_code_string += '    ! df_'+element.forcedMolecule+'/d('+element.sensitivityMolecule+')\n';
      let LUElement = 'LU(i,'+(element.LUArrayIndex+indexOffset)+') '
      for(let iterm = 0; iterm < element.jacobianTerms.length; iterm ++){
        init_jac_code_string += '    !  '+element.jacobianTerms[iterm].reactionString+'\n';
        init_jac_code_string += '    '+LUElement+'= '+LUElement+termToCode(element.jacobianTerms[iterm], moleculeIndex, indexOffset) +'\n\n' ;
      }
    }
    init_jac_code_string += '  end do\n';
    init_jac_code_string += '  !$acc end parallel\n';
    init_jac_code_string += '\n';
    init_jac_code_string += 'end subroutine dforce_dy\n';
    return init_jac_code_string;
  }

  init_jac.factored_alpha_minus_jac = function(indexOffset=0) {
    // Construct unfactored LU = alpha * I - jacobian, then call factorization routine on unfactored LU
    let diagonalIndices = init_jac[0].diagonalIndices;
    let factored_alpha_minus_jac_string  = '\nsubroutine factored_alpha_minus_jac(LU, alpha, dforce_dy)\n';
    factored_alpha_minus_jac_string += '  ! Compute LU decomposition of [\alpha * I - dforce_dy]\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += '  real(r8), intent(in) :: dforce_dy(ncell,number_sparse_factor_elements)\n';
    factored_alpha_minus_jac_string += '  real(r8), intent(in) :: alpha\n';
    factored_alpha_minus_jac_string += '  real(r8), intent(out) :: LU(ncell,number_sparse_factor_elements)\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += '  ! Local variables\n';
    factored_alpha_minus_jac_string += '  integer :: i, j\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n';
    factored_alpha_minus_jac_string += '  !$acc loop gang vector collapse(2)\n';
    factored_alpha_minus_jac_string += '  do j = 1, number_sparse_factor_elements \n';
    factored_alpha_minus_jac_string += '     do i = 1, ncell\n';
    factored_alpha_minus_jac_string += '        LU(i,j) = -dforce_dy(i,j)\n';
    factored_alpha_minus_jac_string += '     end do\n';
    factored_alpha_minus_jac_string += '  end do\n';
    factored_alpha_minus_jac_string += '  !$acc end parallel\n';
    factored_alpha_minus_jac_string += '\n';

    // Add alpha to diagonal elements
    factored_alpha_minus_jac_string += '  ! add alpha to diagonal elements\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += '  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n';
    factored_alpha_minus_jac_string += '  !$acc loop gang vector\n';
    factored_alpha_minus_jac_string += '  do i = 1, ncell\n';
    for(let iRank = 0; iRank < diagonalIndices.length; iRank++){
      let diag = diagonalIndices[iRank] + indexOffset;
      factored_alpha_minus_jac_string += '    LU(i,'+ diag + ') = -dforce_dy(i,'+ diag + ') + alpha\n';
    }

    factored_alpha_minus_jac_string += '  end do\n';
    factored_alpha_minus_jac_string += '  !$acc end parallel\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += '  call factor(LU)\n';
    factored_alpha_minus_jac_string += '\n';
    factored_alpha_minus_jac_string += 'end subroutine factored_alpha_minus_jac\n';

    return factored_alpha_minus_jac_string;
  }

  init_jac.solve_LU_times_x_equals_y_toCode = function(indexOffset=0) {
    //console.log(indexOffset);
  // input y, factored G
  } 

  init_jac.dforce_dy_times_vector_string = function(indexOffset=0){
  // Construct code for dF/dy * vector
    let dforce_dy_times_vector_string  = '\npure subroutine dforce_dy_times_vector(dforce_dy, vector, cummulative_product)\n';
    dforce_dy_times_vector_string += '  !  Compute product of [ dforce_dy * vector ]\n';
    dforce_dy_times_vector_string += '  !  Commonly used to compute time-truncation errors [dforce_dy * force ]\n\n';
    dforce_dy_times_vector_string += '  real(r8), intent(in) :: dforce_dy(ncell,number_sparse_factor_elements) ! Jacobian of forcing\n';
    dforce_dy_times_vector_string += '  real(r8), intent(in) :: vector(ncell,number_of_species)    ! Vector ordered as the order of number density in dy\n';
    dforce_dy_times_vector_string += '  real(r8), intent(out) :: cummulative_product(ncell,number_of_species)  ! Product of jacobian with vector\n';
    dforce_dy_times_vector_string += '\n';
    dforce_dy_times_vector_string += '  ! Local variables\n';
    dforce_dy_times_vector_string += '  integer :: i, j\n';
    dforce_dy_times_vector_string += '\n';
    dforce_dy_times_vector_string += '  !$acc parallel default(present) vector_length(VLEN)\n';
    dforce_dy_times_vector_string += '  !$acc loop gang vector collapse(2)\n';
    dforce_dy_times_vector_string += '  do j = 1, number_of_species\n';
    dforce_dy_times_vector_string += '     do i = 1, ncell\n';
    dforce_dy_times_vector_string += '        cummulative_product(i,j) = 0\n';
    dforce_dy_times_vector_string += '     end do\n';
    dforce_dy_times_vector_string += '  end do\n';
    dforce_dy_times_vector_string += '  !$acc end parallel\n';
    dforce_dy_times_vector_string += '\n';
    dforce_dy_times_vector_string += '  !$acc parallel default(present) vector_length(VLEN)\n';
    dforce_dy_times_vector_string += '  !$acc loop gang vector\n';
    dforce_dy_times_vector_string += '  do i = 1, ncell\n';

    for (let ijac = 0; ijac < init_jac.length; ijac++){
      let element = init_jac[ijac];
      dforce_dy_times_vector_string += '\n    ! df_'+element.forcedMolecule+'/d('+element.sensitivityMolecule+') * '+element.sensitivityMolecule+'_temporary\n';
      let LUElement = 'dforce_dy(i,'+(element.LUArrayIndex+indexOffset)+')'
      let forceIndex = moleculeIndex[element.forcedMolecule]+ indexOffset;
      let sensitivityIndex = moleculeIndex[element.sensitivityMolecule]+ indexOffset;
      dforce_dy_times_vector_string += '    cummulative_product(i,'+forceIndex+') = cummulative_product(i,'+forceIndex+') + ';
      dforce_dy_times_vector_string += LUElement+' * vector(i,'+sensitivityIndex+')\n' ;
    }
    dforce_dy_times_vector_string += '\n';
    dforce_dy_times_vector_string += '  end do\n';
    dforce_dy_times_vector_string += '  !$acc end parallel\n';
    dforce_dy_times_vector_string += '\n';
    dforce_dy_times_vector_string  += 'end subroutine dforce_dy_times_vector\n';
    return dforce_dy_times_vector_string;
  }

  force.toCode = function(indexOffset=0) {

    let force_code_string = "\n";
    force_code_string +="subroutine p_force(rate_constant, number_density, number_density_air, force)\n";
    force_code_string +="  ! Compute force function for all molecules\n";
    force_code_string +="\n";
    force_code_string +="  real(r8), intent(in) :: rate_constant(ncell,number_of_reactions)\n";
    force_code_string +="  real(r8), intent(in) :: number_density(ncell,number_of_species)\n";
    force_code_string +="  real(r8), intent(in) :: number_density_air(ncell)\n";
    force_code_string +="  real(r8), intent(out) :: force(ncell,number_of_species)\n";
    force_code_string +="\n";
    force_code_string +="  ! Local variables\n";
    force_code_string +="  integer :: i\n";
    force_code_string +="\n";
    force_code_string +="  !$acc parallel default(present) vector_length(VLEN) async(STREAM0)\n";
    force_code_string +="  !$acc loop gang vector\n";
    force_code_string +="  do i = 1, ncell\n";

    for(let iMolecule = 0; iMolecule < force.length; iMolecule++ ){
      let forceString = "force(i,"+(iMolecule+indexOffset)+")";
      force_code_string +="\n    ! "+force[iMolecule].constituentName+"\n";
      force_code_string +="    "+forceString+" = 0\n";

      let nTendency = force[iMolecule].tendency.length;
      for (let iTendency = 0; iTendency < nTendency; iTendency ++){
        let termCode = termToCode(force[iMolecule].tendency[iTendency], moleculeIndex, indexOffset);
        force_code_string +="\n    ! "+ force[iMolecule].tendency[iTendency].reactionString+"\n";
        force_code_string +="    "+forceString+" = "+forceString +" "+ termCode+"\n";
      }
    }

    force_code_string +="  end do\n";
    force_code_string +="  !$acc end parallel\n";
    force_code_string +="\n";
    force_code_string +="end subroutine p_force\n";

    return force_code_string;

  }

  // Generate code for calculating rates and naming reactions
  allReactions.calcRatesToCode = function(indexOffset=0) {

    let code_string = "\n";
    code_string += "subroutine calc_reaction_rates(rate_constant, number_density, number_density_air, reaction_rates)\n";
    code_string += "  ! Compute reaction rates\n";
    code_string += "\n";
    code_string += "  real(r8), intent(in)  :: rate_constant(ncell,number_of_reactions)\n";
    code_string += "  real(r8), intent(in)  :: number_density(ncell,number_of_species)\n";
    code_string += "  real(r8), intent(in)  :: number_density_air(ncell)\n";
    code_string += "  real(r8), intent(out) :: reaction_rates(ncell,number_of_reactions)\n";
    code_string += "\n";
    code_string += "  ! Local variables\n";
    code_string += "  integer :: i\n";
    code_string += "\n";
    code_string += "  !$acc parallel default(present) vector_length(VLEN)\n";
    code_string += "  !$acc loop gang vector\n";
    code_string += "  do i = 1, ncell\n";

    this.forEach(function(reaction) {
      let rateTerm = new term(reaction.idxReaction, reaction.reactants, reaction.troe, 1, reaction.reactionString);
      let termCode = termToRateCode(rateTerm, moleculeIndex, indexOffset);
      code_string += "\n";
      code_string += "    ! "+rateTerm.reactionString+"\n";
      code_string += "    reaction_rates(i,"+ (+reaction.idxReaction + +1) +") = "+termCode+"\n";
    });

    code_string += "\n";
    code_string += "  end do\n";
    code_string += "  !$acc end parallel\n";
    code_string += "\n";
    code_string += "end subroutine calc_reaction_rates\n";
    code_string += "\n";

    return code_string;
  }

  // Generate code for an array of reaction names
  allReactions.rateNamesToCode = function(indexOffset=0) {

    let code_string = "\n"
    code_string += "function reaction_names()\n";
    code_string += "  ! Reaction names\n";
    code_string += "\n";
    code_string += "  character(len=128) :: reaction_names(number_of_reactions)\n";
    code_string += "\n";

    this.forEach(function(reaction) {
      code_string += "  reaction_names("+ (+reaction.idxReaction + +1) + ") = '"+reaction.label+"'\n";
    });

    code_string += "\n";
    code_string += "end function reaction_names\n";
    code_string += "\n";

    return code_string;

  }

  // Generate code for an array of photolysis reaction names
  photolysisLabels.photolysisNamesToCode = function() {

    let code_string = "\n"
    code_string += "function photolysis_names()\n"
    code_string += "  ! Photolysis reaction names\n"
    code_string += "\n"
    code_string += "  character(len=28) :: photolysis_names(number_of_photolysis_reactions)\n"
    code_string += "\n"

    this.forEach(function(label, index) {
      code_string += "  photolysis_names("+ (+index + +1) +") = '"+label+"'\n"
    });

    code_string += "\n"
    code_string += "end function photolysis_names\n"
    code_string += "\n"

    return code_string;
  }


  // Generate code for an array of species names
  reorderedMolecules.speciesNamesToCode = function(indexOffset=0) {

    let code_string = "\n";
    code_string += "function species_names()\n";
    code_string += "  ! Chemical species names\n";
    code_string += "\n";
    code_string += "  character(len=128) :: species_names(number_of_species)\n";
    code_string += "\n";

    this.forEach(function(species) {
      code_string += "  species_names("+ (+moleculeIndex[species.moleculename] + +1) + ") = '"+species.moleculename+"'\n";
    });

    code_string += "\n";
    code_string += "end function species_names\n";
    code_string += "\n";

    return code_string;

  }

  let indexOffset = 1; //convert to fortran
  let module = "module kinetics_utilities\n";
  module += "use musica_constants, only: r8 => musica_dk\n";
  module += "use constants, only : ncell=>kNumberOfGridCells, VLEN, &\n";
  module += "                      STREAM0\n\n";
  module += "! This code was generated by Preprocessor revision "+revision+"\n"
  module += "! Preprocessor source "+git_remote+"\n\n"
  module += "! "+res.locals.tagDescription+"\n";
  module += "! "+res.locals.tagStats+"\n\n";
  module += "  use factor_solve_utilities, only : factor, number_of_species, &\n"
  module += "                                     number_sparse_factor_elements\n\n"
  module += "  implicit none\n\n";
  module += "  private\n";
  module += "  public :: dforce_dy_times_vector, factored_alpha_minus_jac, p_force, calc_reaction_rates, reaction_names, &\n"
  module += "            photolysis_names, dforce_dy, species_names\n";
  module += "\n";
  module += "  ! Total number of reactions\n";
  module += "  integer, parameter, public  :: number_of_reactions                = "+allReactions.length+"\n";
  module += "  integer, parameter, public  :: number_of_photolysis_reactions     = "+photolysisLabels.length+"\n";
  module += "\n";
  module += "  contains\n";
  module += init_jac.toCode(indexOffset);
  module += init_jac.factored_alpha_minus_jac(indexOffset);
  module += force.toCode(indexOffset);
  module += allReactions.calcRatesToCode(indexOffset);
  module += allReactions.rateNamesToCode(indexOffset);
  module += photolysisLabels.photolysisNamesToCode(reactions.length, indexOffset);
  module += reorderedMolecules.speciesNamesToCode(indexOffset);
  module += init_jac.dforce_dy_times_vector_string(indexOffset);
  module += "\nend module kinetics_utilities\n";


  let init_jac_fortran = init_jac.toCode(indexOffset);
  let factored_alpha_minus_jac = init_jac.factored_alpha_minus_jac(indexOffset);
  let force_fortran = force.toCode(indexOffset);
  let dforce_dy_times_vector_string = init_jac.dforce_dy_times_vector_string(indexOffset);

  res.locals.preprocessorVersion = revision; 
  res.locals.init_jac_code_string = init_jac_fortran;
  res.locals.factored_alpha_minus_jac = factored_alpha_minus_jac;
  res.locals.force = force_fortran;
  res.locals.dforce_dy_times_vector = dforce_dy_times_vector_string; 
  res.locals.kinetics_utilities_module = module;

  next()

/*
  res.json({
    "preprocessorVersion": revision, 
    "init_jac_code_string":init_jac_fortran,
    "factored_alpha_minus_jac":factored_alpha_minus_jac,
    "force":force_fortran,
    "dforce_dy_times_vector":dforce_dy_times_vector_string, 
    "module" : module
  });
*/

}

var sequence =[constructJacobian, constructSparseLUFactor, toCode];
app.post('/constructJacobian/v0.1/', sequence, function(req, res, next) {
  //console.log(res.locals);
  res.json({
    "kinetics_utilities_module":res.locals.kinetics_utilities_module,
    "rate_constants_utility_module":res.locals.rate_constants_utility_module,
    "factor_solve_utilities_module":res.locals.factor_solve_utilities_module,
    "j_labels":res.locals.j_labels,
    "k_labels":res.locals.k_labels
  });
});

// This can go away once unversioned mechanisms are removed
app.post('/constructJacobian/', sequence, function(req, res, next) {
  //console.log(res.locals);
  res.json({
    "kinetics_utilities_module":res.locals.kinetics_utilities_module,
    "rate_constants_utility_module":res.locals.rate_constants_utility_module,
    "factor_solve_utilities_module":res.locals.factor_solve_utilities_module,
    "j_labels":res.locals.j_labels,
    "k_labels":res.locals.k_labels
  });
});

var serverError = function(err){
  console.log("Server produced error")
  console.log("Most common cause is that this port is already in use")
  console.log("The reason the port is typically in use is that someone is already running this server")
  console.log("Code " + err.code)
  console.log("Syscall " +err.syscall)
  console.log("Port " +err.port)
}


http.listen(3000, function(){
    var addr = http.address();
    console.log('app listening on ' + addr.address + ':' + addr.port);
}).on('error', serverError);

